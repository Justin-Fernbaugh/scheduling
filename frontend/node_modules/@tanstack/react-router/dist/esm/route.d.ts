import { RootRouteId } from './root.js';
import { UseNavigateResult } from './useNavigate.js';
import { MakeRouteMatch, RouteMatch } from './Matches.js';
import { NavigateOptions, ParsePathParams, ToMaskOptions } from './link.js';
import { ParsedLocation } from './location.js';
import { RouteById, RouteIds, RoutePaths } from './routeInfo.js';
import { AnyRouter, RegisteredRouter, Router } from './router.js';
import { Assign, Expand, NoInfer, PickRequired } from './utils.js';
import { BuildLocationFn, NavigateFn } from './RouterProvider.js';
import { NotFoundError } from './not-found.js';
import { LazyRoute } from './fileRoute.js';
import type * as React from 'react';
export type AnyPathParams = {};
export type SearchSchemaInput = {
    __TSearchSchemaInput__: 'TSearchSchemaInput';
};
export type AnySearchSchema = {};
export type AnyContext = {};
export interface RouteContext {
}
export type PreloadableObj = {
    preload?: () => Promise<void>;
};
export type RoutePathOptions<TCustomId, TPath> = {
    path: TPath;
} | {
    id: TCustomId;
};
export interface StaticDataRouteOption {
}
export type RoutePathOptionsIntersection<TCustomId, TPath> = {
    path: TPath;
    id: TCustomId;
};
export type RouteOptions<TParentRoute extends AnyRoute = AnyRoute, TCustomId extends string = string, TPath extends string = string, TSearchValidator extends AnySearchValidator = DefaultSearchValidator, TParams = AnyPathParams, TAllParams = TParams, TRouteContextReturn = RouteContext, TRouteContext = RouteContext, TParentAllContext = AnyContext, TAllContext = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn = {}, TLoaderData = ResolveLoaderData<TLoaderDataReturn>> = BaseRouteOptions<TParentRoute, TCustomId, TPath, TSearchValidator, TParams, TAllParams, TRouteContextReturn, TParentAllContext, TAllContext, TLoaderDeps, TLoaderDataReturn> & UpdatableRouteOptions<NoInfer<TParentRoute>, NoInfer<TCustomId>, NoInfer<TAllParams>, NoInfer<TSearchValidator>, NoInfer<TLoaderData>, NoInfer<TAllContext>, NoInfer<TRouteContext>, NoInfer<TLoaderDeps>>;
export type ParseParamsFn<TPath extends string, TParams> = (rawParams: Record<ParsePathParams<TPath>, string>) => TParams extends Record<ParsePathParams<TPath>, any> ? TParams : Record<ParsePathParams<TPath>, any>;
export type StringifyParamsFn<TPath extends string, TParams> = (params: TParams) => Record<ParsePathParams<TPath>, string>;
export type ParamsOptions<TPath extends string, TParams> = {
    params?: {
        parse: ParseParamsFn<TPath, TParams>;
        stringify: StringifyParamsFn<TPath, TParams>;
    };
    /**
    @deprecated Use params.parse instead
    */
    parseParams?: ParseParamsFn<TPath, TParams>;
    /**
    @deprecated Use params.stringify instead
    */
    stringifyParams?: StringifyParamsFn<TPath, TParams>;
};
export interface FullSearchSchemaOption<TFullSearchSchema> {
    search: TFullSearchSchema;
}
export type FileBaseRouteOptions<TParentRoute extends AnyRoute = AnyRoute, TPath extends string = string, TSearchValidator extends AnySearchValidator = undefined, TParams = {}, TAllParams = {}, TRouteContextReturn = RouteContext, TParentAllContext = AnyContext, TAllContext = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn = {}> = {
    validateSearch?: TSearchValidator;
    shouldReload?: boolean | ((match: LoaderFnContext<TAllParams, ResolveFullSearchSchema<TParentRoute, TSearchValidator>, TAllContext>) => any);
    beforeLoad?: (ctx: BeforeLoadContext<ResolveFullSearchSchema<TParentRoute, TSearchValidator>, TAllParams, TParentAllContext>) => Promise<TRouteContextReturn> | TRouteContextReturn | void;
    loaderDeps?: (opts: FullSearchSchemaOption<ResolveFullSearchSchema<TParentRoute, TSearchValidator>>) => TLoaderDeps;
    loader?: (ctx: LoaderFnContext<TAllParams, TLoaderDeps, TAllContext>) => TLoaderDataReturn | Promise<TLoaderDataReturn>;
} & ParamsOptions<TPath, TParams>;
export type BaseRouteOptions<TParentRoute extends AnyRoute = AnyRoute, TCustomId extends string = string, TPath extends string = string, TSearchValidator extends AnySearchValidator = undefined, TParams = {}, TAllParams = {}, TRouteContextReturn = RouteContext, TParentAllContext = AnyContext, TAllContext = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn = {}> = RoutePathOptions<TCustomId, TPath> & FileBaseRouteOptions<TParentRoute, TPath, TSearchValidator, TParams, TAllParams, TRouteContextReturn, TParentAllContext, TAllContext, TLoaderDeps, TLoaderDataReturn> & {
    getParentRoute: () => TParentRoute;
};
export interface BeforeLoadContext<TFullSearchSchema, TAllParams, TParentAllContext> extends FullSearchSchemaOption<TFullSearchSchema> {
    abortController: AbortController;
    preload: boolean;
    params: Expand<TAllParams>;
    context: TParentAllContext;
    location: ParsedLocation;
    /**
     * @deprecated Use `throw redirect({ to: '/somewhere' })` instead
     **/
    navigate: NavigateFn;
    buildLocation: BuildLocationFn;
    cause: 'preload' | 'enter' | 'stay';
}
export type UpdatableRouteOptions<TParentRoute extends AnyRoute, TRouteId, TAllParams, TSearchValidator extends AnySearchValidator, TLoaderData, TAllContext, TRouteContext, TLoaderDeps> = {
    caseSensitive?: boolean;
    wrapInSuspense?: boolean;
    component?: RouteComponent;
    errorComponent?: false | null | ErrorRouteComponent;
    notFoundComponent?: NotFoundRouteComponent;
    pendingComponent?: RouteComponent;
    pendingMs?: number;
    pendingMinMs?: number;
    staleTime?: number;
    gcTime?: number;
    preloadStaleTime?: number;
    preloadGcTime?: number;
    preSearchFilters?: Array<SearchFilter<ResolveFullSearchSchema<TParentRoute, TSearchValidator>>>;
    postSearchFilters?: Array<SearchFilter<ResolveFullSearchSchema<TParentRoute, TSearchValidator>>>;
    onCatch?: (error: Error, errorInfo: React.ErrorInfo) => void;
    onError?: (err: any) => void;
    onEnter?: (match: RouteMatch<TRouteId, TAllParams, ResolveFullSearchSchema<TParentRoute, TSearchValidator>, TLoaderData, TAllContext, TRouteContext, TLoaderDeps>) => void;
    onStay?: (match: RouteMatch<TRouteId, TAllParams, ResolveFullSearchSchema<TParentRoute, TSearchValidator>, TLoaderData, TAllContext, TRouteContext, TLoaderDeps>) => void;
    onLeave?: (match: RouteMatch<TRouteId, TAllParams, ResolveFullSearchSchema<TParentRoute, TSearchValidator>, TLoaderData, TAllContext, TRouteContext, TLoaderDeps>) => void;
    meta?: (ctx: {
        matches: Array<RouteMatch<TRouteId, TAllParams, ResolveFullSearchSchema<TParentRoute, TSearchValidator>, TLoaderData, TAllContext, TRouteContext, TLoaderDeps>>;
        match: RouteMatch<TRouteId, TAllParams, ResolveFullSearchSchema<TParentRoute, TSearchValidator>, TLoaderData, TAllContext, TRouteContext, TLoaderDeps>;
        params: TAllParams;
        loaderData: TLoaderData;
    }) => Array<React.JSX.IntrinsicElements['meta']>;
    links?: () => Array<React.JSX.IntrinsicElements['link']>;
    scripts?: () => Array<React.JSX.IntrinsicElements['script']>;
    headers?: (ctx: {
        loaderData: TLoaderData;
    }) => Record<string, string>;
} & UpdatableStaticRouteOption;
export type UpdatableStaticRouteOption = {} extends PickRequired<StaticDataRouteOption> ? {
    staticData?: StaticDataRouteOption;
} : {
    staticData: StaticDataRouteOption;
};
export type MetaDescriptor = {
    charSet: 'utf-8';
} | {
    title: string;
} | {
    name: string;
    content: string;
} | {
    property: string;
    content: string;
} | {
    httpEquiv: string;
    content: string;
} | {
    'script:ld+json': LdJsonObject;
} | {
    tagName: 'meta' | 'link';
    [name: string]: string;
} | Record<string, unknown>;
type LdJsonObject = {
    [Key in string]: LdJsonValue;
} & {
    [Key in string]?: LdJsonValue | undefined;
};
type LdJsonArray = Array<LdJsonValue> | ReadonlyArray<LdJsonValue>;
type LdJsonPrimitive = string | number | boolean | null;
type LdJsonValue = LdJsonPrimitive | LdJsonObject | LdJsonArray;
export type RouteLinkEntry = {};
export interface SearchValidatorObj<TInput, TOutput> {
    parse: SearchValidatorFn<TInput, TOutput>;
}
export type AnySearchValidatorObj = SearchValidatorObj<any, any>;
export interface SearchValidatorAdapter<TInput, TOutput> {
    types: {
        input: TInput;
        output: TOutput;
    };
    parse: (input: unknown) => TOutput;
}
export type AnySearchValidatorAdapter = SearchValidatorAdapter<any, any>;
export type AnySearchValidatorFn = SearchValidatorFn<any, any>;
export type SearchValidatorFn<TInput, TOutput> = (input: TInput) => TOutput;
export type SearchValidator<TInput, TOutput> = SearchValidatorObj<TInput, TOutput> | SearchValidatorFn<TInput, TOutput> | SearchValidatorAdapter<TInput, TOutput> | undefined;
export type AnySearchValidator = SearchValidator<any, any>;
export type DefaultSearchValidator = SearchValidator<Record<string, unknown>, AnySearchSchema>;
export type RouteLoaderFn<in out TAllParams = {}, in out TLoaderDeps extends Record<string, any> = {}, in out TAllContext = AnyContext, TLoaderData = undefined> = (match: LoaderFnContext<TAllParams, TLoaderDeps, TAllContext>) => TLoaderData | Promise<TLoaderData>;
export interface LoaderFnContext<in out TAllParams = {}, in out TLoaderDeps = {}, in out TAllContext = AnyContext> {
    abortController: AbortController;
    preload: boolean;
    params: Expand<TAllParams>;
    deps: TLoaderDeps;
    context: TAllContext;
    location: ParsedLocation;
    /**
     * @deprecated Use `throw redirect({ to: '/somewhere' })` instead
     **/
    navigate: (opts: NavigateOptions<AnyRouter>) => Promise<void>;
    parentMatchPromise?: Promise<void>;
    cause: 'preload' | 'enter' | 'stay';
    route: Route;
}
export type SearchFilter<TInput, TResult = TInput> = (prev: TInput) => TResult;
export type ResolveId<TParentRoute, TCustomId extends string, TPath extends string> = TParentRoute extends {
    id: infer TParentId extends string;
} ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId> : RootRouteId;
export type InferFullSearchSchema<TRoute> = TRoute extends {
    types: {
        fullSearchSchema: infer TFullSearchSchema;
    };
} ? TFullSearchSchema : {};
export type InferFullSearchSchemaInput<TRoute> = TRoute extends {
    types: {
        fullSearchSchemaInput: infer TFullSearchSchemaInput;
    };
} ? TFullSearchSchemaInput : {};
export type InferAllParams<TRoute> = TRoute extends {
    types: {
        allParams: infer TAllParams;
    };
} ? TAllParams : {};
export type InferAllContext<TRoute> = TRoute extends {
    types: {
        allContext: infer TAllContext;
    };
} ? TAllContext : {};
export type ResolveSearchSchemaFnInput<TSearchValidator extends AnySearchValidator> = TSearchValidator extends (input: infer TSearchSchemaInput) => any ? TSearchSchemaInput extends SearchSchemaInput ? Omit<TSearchSchemaInput, keyof SearchSchemaInput> : ResolveSearchSchemaFn<TSearchValidator> : AnySearchSchema;
export type ResolveSearchSchemaInput<TSearchValidator extends AnySearchValidator> = TSearchValidator extends AnySearchValidatorAdapter ? TSearchValidator['types']['input'] : TSearchValidator extends AnySearchValidatorObj ? ResolveSearchSchemaFnInput<TSearchValidator['parse']> : ResolveSearchSchemaFnInput<TSearchValidator>;
export type ResolveSearchSchemaFn<TSearchValidator extends AnySearchValidator> = TSearchValidator extends (...args: any) => infer TSearchSchema ? TSearchSchema : AnySearchSchema;
export type ResolveSearchSchema<TSearchValidator extends AnySearchValidator> = unknown extends TSearchValidator ? TSearchValidator : TSearchValidator extends AnySearchValidatorAdapter ? TSearchValidator['types']['output'] : TSearchValidator extends AnySearchValidatorObj ? ResolveSearchSchemaFn<TSearchValidator['parse']> : ResolveSearchSchemaFn<TSearchValidator>;
export type ResolveFullSearchSchema<TParentRoute extends AnyRoute, TSearchValidator extends AnySearchValidator> = unknown extends TParentRoute ? ResolveSearchSchema<TSearchValidator> : Assign<InferFullSearchSchema<TParentRoute>, ResolveSearchSchema<TSearchValidator>>;
export type ResolveFullSearchSchemaInput<TParentRoute extends AnyRoute, TSearchValidator extends AnySearchValidator> = Assign<InferFullSearchSchemaInput<TParentRoute>, ResolveSearchSchemaInput<TSearchValidator>>;
export type ResolveRouteContext<TRouteContextReturn> = [
    TRouteContextReturn
] extends [never] ? RouteContext : TRouteContextReturn;
export type ResolveAllContext<TParentRoute extends AnyRoute, TRouteContext> = Assign<InferAllContext<TParentRoute>, TRouteContext>;
export type ResolveLoaderData<TLoaderDataReturn> = [TLoaderDataReturn] extends [
    never
] ? undefined : TLoaderDataReturn;
export interface AnyRoute extends Route<any, any, any, any, any, any, any, any, any, any, any, any, any, any, any> {
}
export type AnyRouteWithContext<TContext> = Route<any, any, any, any, any, any, any, any, any, any, any, any, TContext, any, any>;
export type ResolveAllParamsFromParent<TParentRoute extends AnyRoute, TParams> = Assign<InferAllParams<TParentRoute>, TParams>;
export type RouteConstraints = {
    TParentRoute: AnyRoute;
    TPath: string;
    TFullPath: string;
    TCustomId: string;
    TId: string;
    TSearchSchema: AnySearchSchema;
    TFullSearchSchema: AnySearchSchema;
    TParams: Record<string, any>;
    TAllParams: Record<string, any>;
    TParentContext: AnyContext;
    TRouteContext: RouteContext;
    TAllContext: AnyContext;
    TRouterContext: AnyContext;
    TChildren: unknown;
    TRouteTree: AnyRoute;
};
export declare function getRouteApi<TId extends RouteIds<RegisteredRouter['routeTree']>, TRouter extends AnyRouter = RegisteredRouter, TRoute extends AnyRoute = RouteById<TRouter['routeTree'], TId>, TFullSearchSchema = TRoute['types']['fullSearchSchema'], TAllParams = TRoute['types']['allParams'], TAllContext = TRoute['types']['allContext'], TLoaderDeps = TRoute['types']['loaderDeps'], TLoaderData = TRoute['types']['loaderData']>(id: TId): RouteApi<TId, TRouter, TRoute, TFullSearchSchema, TAllParams, TAllContext, TLoaderDeps, TLoaderData>;
export declare class RouteApi<TId extends RouteIds<RegisteredRouter['routeTree']>, TRouter extends AnyRouter = RegisteredRouter, TRoute extends AnyRoute = RouteById<TRouter['routeTree'], TId>, TFullSearchSchema = TRoute['types']['fullSearchSchema'], TAllParams = TRoute['types']['allParams'], TAllContext = TRoute['types']['allContext'], TLoaderDeps = TRoute['types']['loaderDeps'], TLoaderData = TRoute['types']['loaderData']> {
    id: TId;
    /**
     * @deprecated Use the `getRouteApi` function instead.
     */
    constructor({ id }: {
        id: TId;
    });
    useMatch: <TRouteTree extends AnyRoute = TRouter["routeTree"], TRouteMatch = MakeRouteMatch<TRouteTree, TId>, TSelected = TRouteMatch>(opts?: {
        select?: (match: TRouteMatch) => TSelected;
    }) => TSelected;
    useRouteContext: <TSelected = Expand<TAllContext>>(opts?: {
        select?: (s: Expand<TAllContext>) => TSelected;
    }) => TSelected;
    useSearch: <TSelected = Expand<TFullSearchSchema>>(opts?: {
        select?: (s: Expand<TFullSearchSchema>) => TSelected;
    }) => TSelected;
    useParams: <TSelected = Expand<TAllParams>>(opts?: {
        select?: (s: Expand<TAllParams>) => TSelected;
    }) => TSelected;
    useLoaderDeps: <TSelected = TLoaderDeps>(opts?: {
        select?: (s: TLoaderDeps) => TSelected;
    }) => TSelected;
    useLoaderData: <TSelected = TLoaderData>(opts?: {
        select?: (s: TLoaderData) => TSelected;
    }) => TSelected;
    useNavigate: () => UseNavigateResult<TRoute["fullPath"]>;
    notFound: (opts?: NotFoundError) => NotFoundError;
}
export declare class Route<in out TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute, in out TPath extends RouteConstraints['TPath'] = '/', in out TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<TParentRoute, TPath>, in out TCustomId extends RouteConstraints['TCustomId'] = string, in out TId extends RouteConstraints['TId'] = ResolveId<TParentRoute, TCustomId, TPath>, in out TSearchValidator extends AnySearchValidator = DefaultSearchValidator, in out TParams = Record<ParsePathParams<TPath>, string>, in out TAllParams = ResolveAllParamsFromParent<TParentRoute, TParams>, TRouteContextReturn = RouteContext, in out TRouteContext = ResolveRouteContext<TRouteContextReturn>, in out TAllContext = ResolveAllContext<TParentRoute, TRouteContext>, in out TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn = {}, in out TLoaderData = ResolveLoaderData<TLoaderDataReturn>, in out TChildren = unknown> {
    isRoot: TParentRoute extends Route<any> ? true : false;
    options: RouteOptions<TParentRoute, TCustomId, TPath, TSearchValidator, TParams, TAllParams, TRouteContextReturn, TRouteContext, InferAllContext<TParentRoute>, TAllContext, TLoaderDeps, TLoaderDataReturn, TLoaderData>;
    parentRoute: TParentRoute;
    id: TId;
    path: TPath;
    fullPath: TFullPath;
    to: TrimPathRight<TFullPath>;
    children?: TChildren;
    originalIndex?: number;
    router?: AnyRouter;
    rank: number;
    lazyFn?: () => Promise<LazyRoute<any>>;
    _lazyPromise?: Promise<void>;
    /**
     * @deprecated Use the `createRoute` function instead.
     */
    constructor(options?: RouteOptions<TParentRoute, TCustomId, TPath, TSearchValidator, TParams, TAllParams, TRouteContextReturn, TRouteContext, InferAllContext<TParentRoute>, TAllContext, TLoaderDeps, TLoaderDataReturn, TLoaderData>);
    types: {
        parentRoute: TParentRoute;
        path: TPath;
        to: TrimPathRight<TFullPath>;
        fullPath: TFullPath;
        customId: TCustomId;
        id: TId;
        searchSchema: ResolveSearchSchema<TSearchValidator>;
        searchSchemaInput: ResolveSearchSchemaInput<TSearchValidator>;
        searchValidator: TSearchValidator;
        fullSearchSchema: ResolveFullSearchSchema<TParentRoute, TSearchValidator>;
        fullSearchSchemaInput: ResolveFullSearchSchemaInput<TParentRoute, TSearchValidator>;
        params: TParams;
        allParams: TAllParams;
        routeContext: TRouteContext;
        allContext: TAllContext;
        children: TChildren;
        loaderData: TLoaderData;
        loaderDeps: TLoaderDeps;
    };
    init: (opts: {
        originalIndex: number;
    }) => void;
    addChildren<const TNewChildren extends Record<string, AnyRoute> | ReadonlyArray<AnyRoute>>(children: TNewChildren): Route<TParentRoute, TPath, TFullPath, TCustomId, TId, TSearchValidator, TParams, TAllParams, TRouteContextReturn, TRouteContext, TAllContext, TLoaderDeps, TLoaderDataReturn, TLoaderData, TNewChildren>;
    updateLoader: <TNewLoaderData = unknown>(options: {
        loader: RouteLoaderFn<TAllParams, TLoaderDeps, TAllContext, TNewLoaderData>;
    }) => Route<TParentRoute, TPath, TFullPath, TCustomId, TId, TSearchValidator, TParams, TAllParams, TRouteContextReturn, TRouteContext, TAllContext, TLoaderDeps, TNewLoaderData, TChildren>;
    update: (options: UpdatableRouteOptions<TParentRoute, TCustomId, TAllParams, TSearchValidator, TLoaderData, TAllContext, TRouteContext, TLoaderDeps>) => this;
    lazy: (lazyFn: () => Promise<LazyRoute<any>>) => this;
    useMatch: <TRouter extends AnyRouter = AnyRouter, TRouteTree extends AnyRoute = TRouter["routeTree"], TRouteMatch = MakeRouteMatch<TRouteTree, TId>, TSelected = TRouteMatch>(opts?: {
        select?: (match: TRouteMatch) => TSelected;
    }) => TSelected;
    useRouteContext: <TSelected = Expand<TAllContext>>(opts?: {
        select?: (search: Expand<TAllContext>) => TSelected;
    }) => TSelected;
    useSearch: <TSelected = Expand<ResolveFullSearchSchema<TParentRoute, TSearchValidator>>>(opts?: {
        select?: (search: Expand<ResolveFullSearchSchema<TParentRoute, TSearchValidator>>) => TSelected;
    }) => TSelected;
    useParams: <TSelected = Expand<TAllParams>>(opts?: {
        select?: (search: Expand<TAllParams>) => TSelected;
    }) => TSelected;
    useLoaderDeps: <TSelected = TLoaderDeps>(opts?: {
        select?: (s: TLoaderDeps) => TSelected;
    }) => TSelected;
    useLoaderData: <TSelected = TLoaderData>(opts?: {
        select?: (search: TLoaderData) => TSelected;
    }) => TSelected;
    useNavigate: () => UseNavigateResult<TFullPath>;
}
export declare function createRoute<TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute, TPath extends RouteConstraints['TPath'] = '/', TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<TParentRoute, TPath>, TCustomId extends RouteConstraints['TCustomId'] = string, TId extends RouteConstraints['TId'] = ResolveId<TParentRoute, TCustomId, TPath>, TSearchValidator extends AnySearchValidator = DefaultSearchValidator, TParams = Record<ParsePathParams<TPath>, string>, TAllParams = ResolveAllParamsFromParent<TParentRoute, TParams>, TRouteContextReturn = RouteContext, TRouteContext = ResolveRouteContext<TRouteContextReturn>, TAllContext = ResolveAllContext<TParentRoute, TRouteContext>, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn = {}, TLoaderData = ResolveLoaderData<TLoaderDataReturn>, TChildren = unknown>(options: RouteOptions<TParentRoute, TCustomId, TPath, TSearchValidator, TParams, TAllParams, TRouteContextReturn, TRouteContext, InferAllContext<TParentRoute>, TAllContext, TLoaderDeps, TLoaderDataReturn, TLoaderData>): Route<TParentRoute, TPath, TFullPath, TCustomId, TId, TSearchValidator, TParams, TAllParams, TRouteContextReturn, TRouteContext, TAllContext, TLoaderDeps, TLoaderDataReturn, TLoaderData, TChildren>;
export type AnyRootRoute = RootRoute<any, any, any, any, any, any, any, any>;
export type RootRouteOptions<TSearchValidator extends AnySearchValidator = DefaultSearchValidator, TRouteContextReturn = RouteContext, TRouteContext = ResolveRouteContext<TRouteContextReturn>, TRouterContext = {}, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn = {}, TLoaderData = ResolveLoaderData<TLoaderDataReturn>> = Omit<RouteOptions<any, // TParentRoute
RootRouteId, // TCustomId
'', // TPath
TSearchValidator, {}, // TParams
{}, // TAllParams
TRouteContextReturn, // TRouteContextReturn
TRouteContext, // TRouteContext
TRouterContext, // TParentAllContext
Assign<TRouterContext, TRouteContext>, // TAllContext
TLoaderDeps, TLoaderDataReturn, // TLoaderDataReturn,
TLoaderData>, 'path' | 'id' | 'getParentRoute' | 'caseSensitive' | 'parseParams' | 'stringifyParams' | 'params'>;
export declare function createRootRouteWithContext<TRouterContext extends {}>(): <TSearchValidator extends AnySearchValidator = DefaultSearchValidator, TRouteContextReturn extends RouteContext = RouteContext, TRouteContext extends RouteContext = ResolveRouteContext<TRouteContextReturn>, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn = {}, TLoaderData = ResolveLoaderData<TLoaderDataReturn>>(options?: RootRouteOptions<TSearchValidator, TRouteContextReturn, TRouteContext, TRouterContext, TLoaderDeps, TLoaderDataReturn, TLoaderData>) => RootRoute<TSearchValidator, TRouteContextReturn, TRouteContext, TRouterContext, TLoaderDeps, TLoaderData, ResolveLoaderData<TLoaderData>, unknown>;
/**
 * @deprecated Use the `createRootRouteWithContext` function instead.
 */
export declare const rootRouteWithContext: typeof createRootRouteWithContext;
export declare class RootRoute<in out TSearchValidator extends AnySearchValidator = DefaultSearchValidator, TRouteContextReturn = RouteContext, in out TRouteContext = ResolveRouteContext<TRouteContextReturn>, in out TRouterContext = {}, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn = {}, in out TLoaderData = ResolveLoaderData<TLoaderDataReturn>, TChildren = unknown> extends Route<any, // TParentRoute
'/', // TPath
'/', // TFullPath
string, // TCustomId
RootRouteId, // TId
TSearchValidator, // TSearchValidator
{}, // TParams
{}, // TAllParams
TRouteContextReturn, // TRouteContextReturn
TRouteContext, // TRouteContext
Assign<TRouterContext, TRouteContext>, // TAllContext
TLoaderDeps, TLoaderDataReturn, TLoaderData, TChildren> {
    /**
     * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.
     */
    constructor(options?: RootRouteOptions<TSearchValidator, TRouteContextReturn, TRouteContext, TRouterContext, TLoaderDeps, TLoaderDataReturn, TLoaderData>);
    addChildren<const TNewChildren extends Record<string, AnyRoute> | ReadonlyArray<AnyRoute>>(children: TNewChildren): RootRoute<TSearchValidator, TRouteContextReturn, TRouteContext, TRouterContext, TLoaderDeps, TLoaderDataReturn, TLoaderData, TNewChildren>;
}
export declare function createRootRoute<TSearchValidator extends AnySearchValidator = DefaultSearchValidator, TRouteContextReturn = RouteContext, TRouteContext = ResolveRouteContext<TRouteContextReturn>, TRouterContext = {}, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn = {}, TLoaderData = ResolveLoaderData<TLoaderDataReturn>>(options?: RootRouteOptions<TSearchValidator, TRouteContextReturn, TRouteContext, TRouterContext, TLoaderDeps, TLoaderDataReturn, TLoaderData>): RootRoute<TSearchValidator, TRouteContextReturn, TRouteContext, TRouterContext, TLoaderDeps, TLoaderDataReturn, TLoaderData, unknown>;
export type ResolveFullPath<TParentRoute extends AnyRoute, TPath extends string, TPrefixed = RoutePrefix<TParentRoute['fullPath'], TPath>> = TPrefixed extends RootRouteId ? '/' : TPrefixed;
type RoutePrefix<TPrefix extends string, TPath extends string> = string extends TPath ? RootRouteId : TPath extends string ? TPrefix extends RootRouteId ? TPath extends '/' ? '/' : `/${TrimPath<TPath>}` : `${TPrefix}/${TPath}` extends '/' ? '/' : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}` : never;
export type TrimPath<T extends string> = '' extends T ? '' : TrimPathRight<TrimPathLeft<T>>;
export type TrimPathLeft<T extends string> = T extends `${RootRouteId}/${infer U}` ? TrimPathLeft<U> : T extends `/${infer U}` ? TrimPathLeft<U> : T;
export type TrimPathRight<T extends string> = T extends '/' ? '/' : T extends `${infer U}/` ? TrimPathRight<U> : T;
export type RouteMask<TRouteTree extends AnyRoute> = {
    routeTree: TRouteTree;
    from: RoutePaths<TRouteTree>;
    to?: any;
    params?: any;
    search?: any;
    hash?: any;
    state?: any;
    unmaskOnReload?: boolean;
};
export declare function createRouteMask<TRouteTree extends AnyRoute, TFrom extends RoutePaths<TRouteTree>, TTo extends string>(opts: {
    routeTree: TRouteTree;
} & ToMaskOptions<Router<TRouteTree, 'never'>, TFrom, TTo>): RouteMask<TRouteTree>;
/**
 * @deprecated Use `ErrorComponentProps` instead.
 */
export type ErrorRouteProps = {
    error: unknown;
    info?: {
        componentStack: string;
    };
    reset: () => void;
};
export type ErrorComponentProps = {
    error: Error;
    info?: {
        componentStack: string;
    };
    reset: () => void;
};
export type NotFoundRouteProps = {
    data: unknown;
};
export type ReactNode = any;
export type SyncRouteComponent<TProps> = ((props: TProps) => ReactNode) | React.LazyExoticComponent<(props: TProps) => ReactNode>;
export type AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {
    preload?: () => Promise<void>;
};
export type RouteComponent<TProps = any> = AsyncRouteComponent<TProps>;
export type ErrorRouteComponent = RouteComponent<ErrorComponentProps>;
export type NotFoundRouteComponent = SyncRouteComponent<NotFoundRouteProps>;
export declare class NotFoundRoute<TParentRoute extends AnyRootRoute, TSearchValidator extends AnySearchValidator = DefaultSearchValidator, TRouteContextReturn = AnyContext, TRouteContext = RouteContext, TAllContext = ResolveAllContext<TParentRoute, TRouteContext>, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn = {}, TLoaderData = ResolveLoaderData<TLoaderDataReturn>, TChildren = unknown> extends Route<TParentRoute, '/404', '/404', '404', '404', TSearchValidator, {}, {}, TRouteContextReturn, TRouteContext, TAllContext, TLoaderDeps, TLoaderDataReturn, TLoaderData, TChildren> {
    constructor(options: Omit<RouteOptions<TParentRoute, string, string, TSearchValidator, {}, {}, TRouteContextReturn, TRouteContext, InferAllContext<TParentRoute>, TAllContext, TLoaderDeps, TLoaderDataReturn, TLoaderData>, 'caseSensitive' | 'parseParams' | 'stringifyParams' | 'path' | 'id' | 'params'>);
}
export {};
